# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/01_knn.ipynb (unless otherwise specified).

__all__ = ['KNN']

# Cell
class KNN:

    def __init__(self):
        pass


    def fit(self, X, y):
        """Fit the model using X as training data and y as target values"""
        self.x = X
        self.y = y

    # Find k nearest labeled points and let them vote on the new output:
    def majority_vote(labels: List[str]) -> str:
        vote_counts = Counter[labels]
        winner, winner_count = vote_counts.most_common(1)[0]
        num_winners = len([count for count in vote_counts.values() if count == winner_count])

        if num_winners == 1:
            return winner
        else:
            return majority_vote(labels[:-1])

    def predict(self, k: int,  Labeled_points, labeled_points: List[LabeledPoint], new_point: Vector) -> str:
        """Predict the class labels for the provided data."""
        class LabeledPoint(NamedTuple):
            point: Vector
            label: str

        # order the labeled point from nearest to farthest:
        by_distance = sorted(labeled_points, key = lambda lp: distance(lp.point, new_point))

        # Find the labels for the k closes:
        k_nearest_labels = [lp.label for lp in by_distance[:k]]

        # vote:
        return predict(k_nearest_labels)